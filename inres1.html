<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hand-Controlled Fractal Knot Visualizer</title>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            font-family: Arial, sans-serif;
        }
        canvas { 
            display: block; 
            position: absolute;
            top: 0;
            left: 0;
        }
        #controls {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0,0,0,0.7);
            padding: 10px;
            border-radius: 5px;
            z-index: 100;
            color: white;
            max-width: 300px;
            max-height: 90vh;
            overflow-y: auto;
        }
        .section-title {
            color: #4CAF50;
            font-weight: bold;
            margin-top: 10px;
            border-bottom: 1px solid #666;
            padding-bottom: 5px;
        }
        #info {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background: rgba(0,0,0,0.7);
            padding: 10px;
            border-radius: 5px;
            font-family: monospace;
            color: white;
            z-index: 100;
        }
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.9);
            padding: 20px;
            border-radius: 5px;
            font-size: 18px;
            color: white;
            z-index: 200;
        }
        .slider-container {
            margin: 10px 0;
        }
        label {
            display: inline-block;
            width: 150px;
            color: white;
        }
        #hand-info {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0,0,0,0.7);
            padding: 10px;
            border-radius: 5px;
            color: white;
            z-index: 100;
            max-width: 300px;
        }
    </style>
</head>
<body>
    <div id="controls">
        <div class="section-title">Knot Controls</div>
        <div class="slider-container">
            <label for="dragonflyCount">Dragonfly Count:</label>
            <input type="range" id="dragonflyCount" min="10" max="500" step="10" value="50">
            <span id="count-display">50</span>
        </div>
        
        <div class="slider-container">
            <label for="wingSpeed">Wing Speed:</label>
            <input type="range" id="wingSpeed" min="0.5" max="5" step="0.1" value="2">
        </div>
        
        <div class="slider-container">
            <label for="knotTightness">Knot Tightness:</label>
            <input type="range" id="knotTightness" min="0.1" max="2" step="0.1" value="0.8">
        </div>
        
        <div class="slider-container">
            <label for="knotSize">Knot Size:</label>
            <input type="range" id="knotSize" min="5" max="50" step="1" value="20">
        </div>
        
        <div class="slider-container">
            <label for="fractalIterations">Fractal Iterations:</label>
            <input type="range" id="fractalIterations" min="1" max="5" step="1" value="2">
        </div>
        
        <div class="slider-container">
            <label for="fractalScale">Fractal Scale:</label>
            <input type="range" id="fractalScale" min="0.1" max="0.9" step="0.1" value="0.5">
        </div>
        
        <!-- New video size control -->
        <div class="section-title">Video Controls</div>
        <div class="slider-container">
            <label for="videoSize">Video Size:</label>
            <input type="range" id="videoSize" min="1" max="1000000" step="0.5" value="2">
        </div>
    </div>
    
    <div id="hand-info">
        <div class="section-title">Hand Tracking</div>
        <div>Left Hand: <span id="left-hand-status">Not detected</span></div>
        <div>Right Hand: <span id="right-hand-status">Not detected</span></div>
        <div>Gesture: <span id="gesture-info">None</span></div>
    </div>
    
    <div id="info">Initializing...</div>
    <div id="loading">Loading hand tracking and creating visualizer...</div>
    
    <!-- Import TensorFlow and HandPoseDetection -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest/dist/tf.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/hand-pose-detection@latest/dist/hand-pose-detection.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands@latest/hands.js"></script>
    
    <!-- Import Three.js -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/controls/OrbitControls.js"></script>
    
    <script>
        // Global variables
        let wingSpeed = 2;
        let knotTightness = 0.8;
        let knotSize = 20;
        let knotType = 'trefoil';
        let dragonflies = [];
        let dragonflyCount = 50;
        let fractalIterations = 2;
        let fractalScale = 0.5;
        let time = 0;
        let videoSize = 10000; // New variable for video size
        let backgroundMesh; // Reference to the video background mesh
        
        // Hand tracking variables
        let handDetector;
        let video;
        let videoTexture;
        let leftHandPosition = { x: 0, y: 0, z: 0 };
        let rightHandPosition = { x: 0, y: 0, z: 0 };
        let leftHandDetected = false;
        let rightHandDetected = false;
        let lastGestureTime = 0;
        let currentGesture = 'none';
        
        // List of all knot types
        const knotTypes = [
            'trefoil', 'figure8', 'carrick', 'granny', 'turk', 'celtic', 'borromean', 'hopf', 'stevedore', 'monkey',
            'butterfly', 'chinese', 'solomon', 'cinquefoil', 'square', 'star', 'spiral', 'lissajous', 'torus31',
            'torus51', 'torus52', 'torus71', 'torus72', 'torus91', 'torus92', 'fractal1', 'fractal2', 'fractal3',
            'fractal4', 'fractal5', 'fractal6', 'fractal7', 'fractal8', 'fractal9', 'fractal10', 'fractal11',
            'fractal12', 'fractal13', 'fractal14', 'fractal15'
        ];
        
        // Initialize Three.js components
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 100000);
        camera.position.set(0, 0, 100);
        camera.lookAt(0, 0, 0);
        
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.body.appendChild(renderer.domElement);

        // Add OrbitControls
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.25;
        controls.screenSpacePanning = false;
        controls.maxPolarAngle = Math.PI;
        controls.minDistance = 10;
        controls.maxDistance = 500;

        // Create materials with different colors
        const materials = [
            new THREE.MeshStandardMaterial({ color: 0x4488ff, roughness: 0.2, metalness: 0.8, emissive: 0x4488ff, emissiveIntensity: 0.3, transparent: true, opacity: 0.9 }),
            new THREE.MeshStandardMaterial({ color: 0x44ff88, roughness: 0.2, metalness: 0.8, emissive: 0x44ff88, emissiveIntensity: 0.3, transparent: true, opacity: 0.9 }),
            new THREE.MeshStandardMaterial({ color: 0xff8844, roughness: 0.2, metalness: 0.8, emissive: 0xff8844, emissiveIntensity: 0.3, transparent: true, opacity: 0.9 }),
            new THREE.MeshStandardMaterial({ color: 0xff44ff, roughness: 0.2, metalness: 0.8, emissive: 0xff44ff, emissiveIntensity: 0.3, transparent: true, opacity: 0.9 }),
            new THREE.MeshStandardMaterial({ color: 0xffff44, roughness: 0.2, metalness: 0.8, emissive: 0xffff44, emissiveIntensity: 0.3, transparent: true, opacity: 0.9 })
        ];

        // Add lights
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);
        
        const directionalLight1 = new THREE.DirectionalLight(0xffffff, 1);
        directionalLight1.position.set(1, 1, 1);
        scene.add(directionalLight1);
        
        const directionalLight2 = new THREE.DirectionalLight(0xffffff, 0.5);
        directionalLight2.position.set(-1, -1, -1);
        scene.add(directionalLight2);

        // Create a simplified dragonfly (optimized for many instances)
        function createDragonfly(material, size = 1) {
            const dragonflyGroup = new THREE.Group();
            dragonflyGroup.scale.set(size, size, size);
            
            // Body (simplified)
            const bodyGeometry = new THREE.CylinderGeometry(0.3, 0.1, 4, 6);
            const body = new THREE.Mesh(bodyGeometry, material);
            body.rotation.z = Math.PI / 2;
            dragonflyGroup.add(body);
            
            // Head (simplified)
            const headGeometry = new THREE.SphereGeometry(0.5, 8, 8);
            const head = new THREE.Mesh(headGeometry, material);
            head.position.set(2, 0, 0);
            dragonflyGroup.add(head);
            
            // Create 4 wings (simplified)
            const wingSize = 1.5;
            const wing1 = createWing(wingSize, material);
            wing1.position.set(0, 0.5, 0);
            wing1.rotation.z = Math.PI / 4;
            dragonflyGroup.add(wing1);
            
            const wing2 = createWing(wingSize, material);
            wing2.position.set(0, -0.5, 0);
            wing2.rotation.z = -Math.PI / 4;
            dragonflyGroup.add(wing2);
            
            const wing3 = createWing(wingSize * 0.9, material);
            wing3.position.set(-1, 0.5, 0);
            wing3.rotation.z = Math.PI / 3;
            dragonflyGroup.add(wing3);
            
            const wing4 = createWing(wingSize * 0.9, material);
            wing4.position.set(-1, -0.5, 0);
            wing4.rotation.z = -Math.PI / 3;
            dragonflyGroup.add(wing4);
            
            // Initialize movement parameters
            dragonflyGroup.userData = {
                wings: [wing1, wing2, wing3, wing4],
                position: new THREE.Vector3(),
                velocity: new THREE.Vector3(),
                timeOffset: Math.random() * 100,
                size: size,
                lastPosition: new THREE.Vector3()
            };
            
            return dragonflyGroup;
        }

        // Create a simplified wing
        function createWing(size, material) {
            const wingGeometry = new THREE.PlaneGeometry(size, size * 1.5, 3, 3);
            
            // Shape the wing slightly
            const position = wingGeometry.attributes.position;
            for (let i = 0; i < position.count; i++) {
                const x = position.getX(i);
                const z = Math.sin(x * 2) * 0.1;
                position.setZ(i, z);
            }
            position.needsUpdate = true;
            
            const wing = new THREE.Mesh(wingGeometry, material);
            wing.rotation.x = Math.PI / 2;
            return wing;
        }

        // Calculate positions along different knot types with fractal variations
        function calculateKnotPosition(index, total, timeOffset) {
            const t = (index / total) * Math.PI * 2 + time * 0.1 * knotTightness + timeOffset;
            
            let x = 0, y = 0, z = 0;
            
            // Base position calculation
            switch(knotType) {
                case 'trefoil':
                    x = Math.sin(t) + 0.5 * Math.sin(2 * t);
                    y = Math.cos(t) - 0.5 * Math.cos(2 * t);
                    z = 0.5 * Math.sin(3 * t);
                    break;
                    
                case 'figure8':
                    x = (Math.cos(t) + Math.cos(3 * t));
                    y = (Math.sin(t) + Math.sin(3 * t));
                    z = Math.sin(2 * t);
                    break;
                    
                case 'torus51':
                    const p = 5, q = 1;
                    const r = Math.cos(q * t) + 2;
                    x = r * Math.cos(p * t);
                    y = r * Math.sin(p * t);
                    z = -Math.sin(q * t);
                    break;
                    
                case 'torus52':
                    const p2 = 5, q2 = 2;
                    const r2 = Math.cos(q2 * t) + 2;
                    x = r2 * Math.cos(p2 * t);
                    y = r2 * Math.sin(p2 * t);
                    z = -Math.sin(q2 * t);
                    break;
                    
                case 'torus71':
                    const p3 = 7, q3 = 1;
                    const r3 = Math.cos(q3 * t) + 2;
                    x = r3 * Math.cos(p3 * t);
                    y = r3 * Math.sin(p3 * t);
                    z = -Math.sin(q3 * t);
                    break;
                    
                case 'torus31':
                    x = (2 + Math.cos(3 * t)) * Math.cos(t);
                    y = (2 + Math.cos(3 * t)) * Math.sin(t);
                    z = Math.sin(3 * t);
                    break;
                    
                case 'torus72':
                    x = (2 + Math.cos(7 * t)) * Math.cos(2 * t);
                    y = (2 + Math.cos(7 * t)) * Math.sin(2 * t);
                    z = Math.sin(7 * t);
                    break;
                    
                case 'torus91':
                    x = (2 + Math.cos(9 * t)) * Math.cos(t);
                    y = (2 + Math.cos(9 * t)) * Math.sin(t);
                    z = Math.sin(9 * t);
                    break;
                    
                case 'torus92':
                    x = (2 + Math.cos(9 * t)) * Math.cos(2 * t);
                    y = (2 + Math.cos(9 * t)) * Math.sin(2 * t);
                    z = Math.sin(9 * t);
                    break;
                    
                case 'solomon':
                    x = Math.sin(t) * (1 + 0.3 * Math.cos(5 * t));
                    y = Math.cos(t) * (1 + 0.3 * Math.cos(5 * t));
                    z = 0.3 * Math.sin(5 * t);
                    break;
                    
                case 'cinquefoil':
                    x = (Math.sin(t) + 2 * Math.sin(2 * t));
                    y = (Math.cos(t) - 2 * Math.cos(2 * t));
                    z = (-Math.sin(3 * t));
                    break;
                    
                case 'square':
                    x = (Math.sin(t) + Math.sin(3 * t));
                    y = (Math.cos(t) - Math.cos(3 * t));
                    z = 0.5 * Math.sin(4 * t);
                    break;
                    
                case 'star':
                    x = Math.sin(2 * t) * (3 + Math.cos(5 * t));
                    y = Math.cos(2 * t) * (3 + Math.cos(5 * t));
                    z = Math.sin(5 * t);
                    break;
                    
                case 'spiral':
                    const spiralT = t * 2;
                    x = Math.cos(spiralT) * (1 + 0.5 * Math.cos(5 * spiralT));
                    y = Math.sin(spiralT) * (1 + 0.5 * Math.cos(5 * spiralT));
                    z = 0.5 * Math.sin(5 * spiralT);
                    break;
                    
                case 'lissajous':
                    x = Math.sin(3 * t + Math.PI/2);
                    y = Math.sin(2 * t);
                    z = Math.sin(t);
                    break;
                    
                case 'carrick':
                    x = (Math.sin(t) + 0.5 * Math.sin(3 * t));
                    y = (Math.cos(t) - 0.5 * Math.cos(3 * t));
                    z = 0.3 * Math.sin(2 * t);
                    break;
                    
                case 'granny':
                    x = (Math.sin(t) + 0.3 * Math.sin(3 * t));
                    y = (Math.cos(t) + 0.3 * Math.cos(3 * t));
                    z = 0.2 * Math.sin(4 * t);
                    break;
                    
                case 'turk':
                    const turkP = 3, turkQ = 2;
                    const turkR = Math.cos(turkQ * t) + 2;
                    x = turkR * Math.cos(turkP * t);
                    y = turkR * Math.sin(turkP * t);
                    z = -Math.sin(turkQ * t);
                    break;
                    
                case 'celtic':
                    x = (Math.sin(t) * Math.cos(2 * t));
                    y = (Math.cos(t) * Math.cos(2 * t));
                    z = 0.5 * Math.sin(3 * t);
                    break;
                    
                case 'borromean':
                    const ring = index % 3;
                    const ringT = t + (ring * Math.PI * 2 / 3);
                    if (ring === 0) {
                        x = Math.cos(ringT);
                        y = Math.sin(ringT);
                        z = 0;
                    } else if (ring === 1) {
                        x = Math.cos(ringT);
                        z = Math.sin(ringT);
                        y = 0;
                    } else {
                        y = Math.cos(ringT);
                        z = Math.sin(ringT);
                        x = 0;
                    }
                    break;
                    
                case 'hopf':
                    const hopfRing = index % 2;
                    const hopfT = t + (hopfRing * Math.PI);
                    if (hopfRing === 0) {
                        x = Math.cos(hopfT);
                        y = Math.sin(hopfT);
                        z = 0.3;
                    } else {
                        x = (0.5 + 0.5 * Math.cos(hopfT)) * Math.cos(hopfT/2);
                        y = (0.5 + 0.5 * Math.cos(hopfT)) * Math.sin(hopfT/2);
                        z = 0.5 * Math.sin(hopfT) - 0.3;
                    }
                    break;
                    
                case 'stevedore':
                    x = (Math.sin(t) + 0.2 * Math.sin(5 * t));
                    y = (Math.cos(t) + 0.2 * Math.cos(5 * t));
                    z = 0.3 * Math.sin(3 * t);
                    break;
                    
                case 'monkey':
                    const monkeyT = t * 1.5;
                    x = Math.sin(monkeyT) * (1 + 0.5 * Math.cos(4 * monkeyT));
                    y = Math.cos(monkeyT) * (1 + 0.5 * Math.cos(4 * monkeyT));
                    z = 0.5 * Math.sin(4 * monkeyT);
                    break;
                    
                case 'butterfly':
                    x = Math.sin(t) * (2 + Math.cos(4 * t));
                    y = Math.cos(t) * (2 + Math.cos(4 * t));
                    z = 0.5 * Math.sin(4 * t);
                    break;
                    
                case 'chinese':
                    const buttonT = t * 1.2;
                    x = (Math.sin(buttonT) + 0.3 * Math.sin(3 * buttonT));
                    y = (Math.cos(buttonT) - 0.3 * Math.cos(3 * buttonT));
                    z = 0.4 * Math.sin(2 * buttonT);
                    break;
                    
                // FRACTAL KNOTS
                case 'fractal1': // Fractal Spiral
                    for (let i = 0; i < fractalIterations; i++) {
                        const scale = Math.pow(fractalScale, i);
                        const iterT = t * (i + 1);
                        x += scale * Math.sin(iterT) * Math.cos(iterT * 3);
                        y += scale * Math.cos(iterT) * Math.sin(iterT * 2);
                        z += scale * Math.sin(iterT * 1.5);
                    }
                    break;
                    
                case 'fractal2': // Fractal Lace
                    for (let i = 0; i < fractalIterations; i++) {
                        const scale = Math.pow(fractalScale, i);
                        const iterT = t * (i * 2 + 1);
                        x += scale * (Math.sin(iterT) + 0.3 * Math.sin(iterT * 3));
                        y += scale * (Math.cos(iterT) + 0.3 * Math.cos(iterT * 5));
                        z += scale * 0.5 * Math.sin(iterT * 2);
                    }
                    break;
                    
                case 'fractal3': // Fractal Vortex
                    for (let i = 0; i < fractalIterations; i++) {
                        const scale = Math.pow(fractalScale, i);
                        const iterT = t * (i + 1) * 1.5;
                        const radius = 1 + 0.5 * Math.sin(iterT * 2);
                        x += scale * radius * Math.cos(iterT);
                        y += scale * radius * Math.sin(iterT);
                        z += scale * 0.7 * Math.sin(iterT * 3);
                    }
                    break;
                    
                case 'fractal4': // Fractal Cage
                    for (let i = 0; i < fractalIterations; i++) {
                        const scale = Math.pow(fractalScale, i);
                        const iterT = t * (i * 3 + 1);
                        x += scale * Math.sin(iterT) * (1 + 0.3 * Math.cos(iterT * 5));
                        y += scale * Math.cos(iterT) * (1 + 0.3 * Math.cos(iterT * 7));
                        z += scale * 0.5 * Math.sin(iterT * 3);
                    }
                    break;
                    
                case 'fractal5': // Fractal Helix
                    for (let i = 0; i < fractalIterations; i++) {
                        const scale = Math.pow(fractalScale, i);
                        const iterT = t * (i + 1);
                        const radius = 1 + 0.2 * Math.sin(iterT * 4);
                        x += scale * radius * Math.cos(iterT * 3);
                        y += scale * radius * Math.sin(iterT * 3);
                        z += scale * iterT / Math.PI;
                    }
                    break;
                    
                case 'fractal6': // Fractal Weave
                    for (let i = 0; i < fractalIterations; i++) {
                        const scale = Math.pow(fractalScale, i);
                        const iterT = t * (i * 2 + 1);
                        x += scale * (Math.sin(iterT) + Math.sin(iterT * 3));
                        y += scale * (Math.cos(iterT) - Math.cos(iterT * 3));
                        z += scale * 0.5 * Math.sin(iterT * 2);
                    }
                    break;
                    
                case 'fractal7': // Fractal MÃ¶bius
                    for (let i = 0; i < fractalIterations; i++) {
                        const scale = Math.pow(fractalScale, i);
                        const iterT = t * (i + 1);
                        const radius = 1 + 0.3 * Math.sin(iterT * 3);
                        x += scale * radius * Math.cos(iterT);
                        y += scale * radius * Math.sin(iterT);
                        z += scale * radius * Math.sin(iterT / 2);
                    }
                    break;
                    
                case 'fractal8': // Fractal Flower
                    for (let i = 0; i < fractalIterations; i++) {
                        const scale = Math.pow(fractalScale, i);
                        const iterT = t * (i * 2 + 1);
                        const petals = 5 + i;
                        const radius = 1 + 0.5 * Math.sin(petals * iterT);
                        x += scale * radius * Math.cos(iterT);
                        y += scale * radius * Math.sin(iterT);
                        z += scale * 0.3 * Math.sin(iterT * petals);
                    }
                    break;
                    
                case 'fractal9': // Fractal Snowflake
                    for (let i = 0; i < fractalIterations; i++) {
                        const scale = Math.pow(fractalScale, i);
                        const iterT = t * (i * 3 + 1);
                        const branches = 6;
                        const radius = 1 + 0.4 * Math.sin(branches * iterT);
                        x += scale * radius * Math.cos(iterT);
                        y += scale * radius * Math.sin(iterT);
                        z += scale * 0.2 * Math.sin(iterT * branches * 2);
                    }
                    break;
                    
                case 'fractal10': // Fractal DNA
                    for (let i = 0; i < fractalIterations; i++) {
                        const scale = Math.pow(fractalScale, i);
                        const iterT = t * (i + 1);
                        const twist = 10;
                        x += scale * (Math.cos(iterT) + 0.3 * Math.cos(twist * iterT));
                        y += scale * (Math.sin(iterT) + 0.3 * Math.sin(twist * iterT));
                        z += scale * iterT / Math.PI;
                    }
                    break;
                    
                case 'fractal11': // Fractal Cage 2
                    for (let i = 0; i < fractalIterations; i++) {
                        const scale = Math.pow(fractalScale, i);
                        const iterT = t * (i * 4 + 1);
                        x += scale * Math.sin(iterT) * (1 + 0.5 * Math.cos(iterT * 7));
                        y += scale * Math.cos(iterT) * (1 + 0.5 * Math.cos(iterT * 5));
                        z += scale * 0.5 * Math.sin(iterT * 3);
                    }
                    break;
                    
                case 'fractal12': // Fractal Torus Chain
                    for (let i = 0; i < fractalIterations; i++) {
                        const scale = Math.pow(fractalScale, i);
                        const iterT = t * (i * 2 + 1);
                        const p = 3 + i, q = 1 + i;
                        const radius = Math.cos(q * iterT) + 2;
                        x += scale * radius * Math.cos(p * iterT);
                        y += scale * radius * Math.sin(p * iterT);
                        z += scale * -Math.sin(q * iterT);
                    }
                    break;
                    
                case 'fractal13': // Fractal Infinity
                    for (let i = 0; i < fractalIterations; i++) {
                        const scale = Math.pow(fractalScale, i);
                        const iterT = t * (i + 1);
                        x += scale * Math.sin(iterT);
                        y += scale * Math.sin(iterT) * Math.cos(iterT);
                        z += scale * 0.5 * Math.sin(iterT * 2);
                    }
                    break;
                    
                case 'fractal14': // Fractal Celtic
                    for (let i = 0; i < fractalIterations; i++) {
                        const scale = Math.pow(fractalScale, i);
                        const iterT = t * (i * 3 + 1);
                        x += scale * Math.sin(iterT) * Math.cos(iterT * 2);
                        y += scale * Math.cos(iterT) * Math.cos(iterT * 2);
                        z += scale * 0.5 * Math.sin(iterT * 3);
                    }
                    break;
                    
                case 'fractal15': // Fractal Spiderweb
                    for (let i = 0; i < fractalIterations; i++) {
                        const scale = Math.pow(fractalScale, i);
                        const iterT = t * (i * 5 + 1);
                        const arms = 8;
                        const radius = 1 + 0.5 * Math.sin(arms * iterT);
                        x += scale * radius * Math.cos(iterT);
                        y += scale * radius * Math.sin(iterT);
                        z += scale * 0.3 * Math.sin(iterT * arms * 2);
                    }
                    break;
                    
                default:
                    x = Math.sin(t) + 0.5 * Math.sin(2 * t);
                    y = Math.cos(t) - 0.5 * Math.cos(2 * t);
                    z = 0.5 * Math.sin(3 * t);
            }
            
            // Apply knot size scaling
            x *= knotSize;
            y *= knotSize;
            z *= knotSize;
            
            // Add some subtle noise for organic feel
            const noise = 0.3;
            const nx = x + (Math.random() - 0.5) * noise;
            const ny = y + (Math.random() - 0.5) * noise;
            const nz = z + (Math.random() - 0.5) * noise;
            
            return new THREE.Vector3(nx, ny, nz);
        }
            
        // Add dragonflies to the scene
        function addDragonflies(count) {
            const startTime = performance.now();
            let added = 0;
            
            // Add in batches to prevent UI freeze
            function addBatch() {
                const batchSize = Math.min(50, count - added);
                
                for (let i = 0; i < batchSize; i++) {
                    const material = materials[Math.floor(Math.random() * materials.length)];
                    const size = 0.8 + Math.random() * 0.4;
                    const dragonfly = createDragonfly(material, size);
                    
                    // Position along the knot
                    const index = dragonflies.length + added;
                    const position = calculateKnotPosition(index, count, Math.random());
                    dragonfly.position.copy(position);
                    
                    scene.add(dragonfly);
                    dragonflies.push(dragonfly);
                    added++;
                }
                
                updateCountDisplay();
                
                if (added < count) {
                    updateInfo(`Adding dragonflies: ${added}/${count}`);
                    setTimeout(addBatch, 1);
                } else {
                    updateInfo(`Added ${count} dragonflies in ${(performance.now() - startTime).toFixed(0)}ms`);
                }
            }
            
            addBatch();
        }

        // Remove dragonflies from the scene
        function removeDragonflies(count) {
            count = Math.min(count, dragonflies.length);
            
            for (let i = 0; i < count; i++) {
                if (dragonflies.length > 0) {
                    const dragonfly = dragonflies.pop();
                    scene.remove(dragonfly);
                }
            }
            
            updateCountDisplay();
            updateInfo(`Removed ${count} dragonflies. ${dragonflies.length} remaining.`);
        }

        // Update wing animations and knot movements
        function updateDragonflies(deltaTime) {
            time += deltaTime;
            
            // Update positions along the knot
            dragonflies.forEach((dragonfly, i) => {
                if (!dragonfly.userData) return;
                
                // Wing flapping
                const flapAngle = Math.sin((time + dragonfly.userData.timeOffset) * wingSpeed) * Math.PI / 4;
                dragonfly.userData.wings.forEach((wing, j) => {
                    // Alternate wing directions
                    const direction = j % 2 === 0 ? 1 : -1;
                    wing.rotation.x = flapAngle * direction;
                });
                
                // Store last position for direction calculation
                dragonfly.userData.lastPosition.copy(dragonfly.position);
                
                // Calculate new knot position
                const targetPosition = calculateKnotPosition(i, dragonflies.length, dragonfly.userData.timeOffset);
                
                // Smooth movement toward knot position
                dragonfly.position.lerp(targetPosition, 0.1);
                
                // Calculate direction for orientation
                const direction = new THREE.Vector3().subVectors(
                    dragonfly.position,
                    dragonfly.userData.lastPosition
                ).normalize();
                
                if (direction.length() > 0) {
                    // Face direction of movement
                    dragonfly.quaternion.setFromUnitVectors(
                        new THREE.Vector3(1, 0, 0),
                        direction
                    );
                    
                    // Add slight upward tilt
                    dragonfly.rotation.z += Math.PI / 8;
                }
            });
        }

        // Update video background size
        function updateVideoSize() {
            if (!backgroundMesh) return;
            
            // Scale the background mesh based on the videoSize parameter
            backgroundMesh.scale.set(videoSize, videoSize, 1);
            
            // Adjust position to keep it behind everything
            backgroundMesh.position.z = -10 * videoSize;
        }

        // Update info display
        function updateInfo(message) {
            if (message) {
                document.getElementById('info').textContent = message;
                return;
            }
            
            document.getElementById('info').textContent = 
                `Dragonflies: ${dragonflies.length} | ` +
                `Knot Type: ${knotType} | ` +
                `Wing Speed: ${wingSpeed.toFixed(1)} | ` +
                `Knot Tightness: ${knotTightness.toFixed(1)} | ` +
                `Knot Size: ${knotSize.toFixed(0)} | ` +
                `Fractal: ${fractalIterations} iters @ ${fractalScale.toFixed(1)} | ` +
                `Video Size: ${videoSize.toFixed(1)}`;
        }

        function updateCountDisplay() {
            document.getElementById('count-display').textContent = dragonflies.length;
            document.getElementById('dragonflyCount').value = dragonflies.length;
        }

        // Initialize camera for hand tracking
        async function initCamera() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: {
                        width: 1280,
                        height: 720,
                        facingMode: 'user'
                    }
                });

                video = document.createElement('video');
                video.srcObject = stream;
                video.playsInline = true;
                
                await new Promise((resolve) => {
                    video.onloadedmetadata = resolve;
                    video.play().catch(console.error);
                });

                // Create video texture for background
                videoTexture = new THREE.VideoTexture(video);
                videoTexture.minFilter = THREE.LinearFilter;
                videoTexture.magFilter = THREE.LinearFilter;

                // Create background plane
                const geometry = new THREE.PlaneGeometry(2, 2);
                const material = new THREE.MeshBasicMaterial({
                    map: videoTexture,
                    transparent: true,
                    opacity: 0.8
                });
                
                backgroundMesh = new THREE.Mesh(geometry, material);
                backgroundMesh.position.z = -10;
                scene.add(backgroundMesh);

                // Set initial video size
                updateVideoSize();

                updateInfo('Camera initialized successfully');
                return true;
            } catch (error) {
                console.error('Camera initialization failed:', error);
                updateInfo('Camera access failed - using default background');
                return false;
            }
        }

        // Initialize hand tracking
        async function initHandTracking() {
            try {
                handDetector = await window.handPoseDetection.createDetector(
                    window.handPoseDetection.SupportedModels.MediaPipeHands,
                    {
                        runtime: 'mediapipe',
                        modelType: 'full',
                        maxHands: 2,
                        solutionPath: 'https://cdn.jsdelivr.net/npm/@mediapipe/hands@latest'
                    }
                );

                updateInfo('Hand tracking initialized');
                detectHands();
            } catch (error) {
                console.error('Hand tracking initialization failed:', error);
                updateInfo('Hand tracking failed - using mouse controls');
            }
        }

        // Detect hands in video stream
        async function detectHands() {
            if (!handDetector || !video) return;

            try {
                const hands = await handDetector.estimateHands(video);
                
                // Reset hand detection
                leftHandDetected = false;
                rightHandDetected = false;
                
                if (hands.length > 0) {
                    hands.forEach(hand => {
                        const { keypoints, handedness } = hand;
                        
                        // Calculate average hand position
                        const sum = keypoints.reduce((acc, { x, y }) => {
                            acc.x += x;
                            acc.y += y;
                            return acc;
                        }, { x: 0, y: 0 });

                        // Normalize to [-1, 1] range
                        const handPos = {
                            x: (sum.x / keypoints.length / video.videoWidth) * 2 - 1,
                            y: -((sum.y / keypoints.length / video.videoHeight) * 2 - 1),
                            z: 0
                        };
                        
                        // Store based on handedness
                        if (handedness === 'Left') {
                            leftHandPosition = handPos;
                            leftHandDetected = true;
                            document.getElementById('left-hand-status').textContent = 'Detected';
                        } else {
                            rightHandPosition = handPos;
                            rightHandDetected = true;
                            document.getElementById('right-hand-status').textContent = 'Detected';
                        }
                    });
                    
                    // Detect gestures
                    detectGestures(hands);
                } else {
                    document.getElementById('left-hand-status').textContent = 'Not detected';
                    document.getElementById('right-hand-status').textContent = 'Not detected';
                    document.getElementById('gesture-info').textContent = 'None';
                    currentGesture = 'none';
                }
            } catch (error) {
                console.error('Hand detection error:', error);
            }

            requestAnimationFrame(detectHands);
        }

        // Detect hand gestures
        function detectGestures(hands) {
            const now = performance.now();
            
            // Only check gestures every 500ms to prevent rapid switching
            if (now - lastGestureTime < 500) return;
            
            // Check for swipe gestures to change knot type
            hands.forEach(hand => {
                const { keypoints, handedness } = hand;
                
                // Get thumb and index finger positions
                const thumbTip = keypoints.find(k => k.name === 'thumb_tip');
                const indexTip = keypoints.find(k => k.name === 'index_finger_tip');
                
                if (thumbTip && indexTip) {
                    // Calculate distance between thumb and index finger
                    const dx = thumbTip.x - indexTip.x;
                    const dy = thumbTip.y - indexTip.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    // Normalize by hand size (distance from wrist to middle finger)
                    const wrist = keypoints.find(k => k.name === 'wrist');
                    const middleTip = keypoints.find(k => k.name === 'middle_finger_tip');
                    if (wrist && middleTip) {
                        const handSize = Math.sqrt(
                            Math.pow(wrist.x - middleTip.x, 2) + 
                            Math.pow(wrist.y - middleTip.y, 2)
                        );
                        
                        const normalizedDistance = distance / handSize;
                        
                        // Pinch gesture to change knot type
                        if (normalizedDistance < 0.2) {
                            const currentIndex = knotTypes.indexOf(knotType);
                            let newIndex;
                            
                            if (handedness === 'Left') {
                                // Left hand pinch - move to previous knot
                                newIndex = (currentIndex - 1 + knotTypes.length) % knotTypes.length;
                                document.getElementById('gesture-info').textContent = 'Pinch (Left) - Previous knot';
                            } else {
                                // Right hand pinch - move to next knot
                                newIndex = (currentIndex + 1) % knotTypes.length;
                                document.getElementById('gesture-info').textContent = 'Pinch (Right) - Next knot';
                            }
                            
                            knotType = knotTypes[newIndex];
                            updateInfo(`Changed to ${knotType} knot`);
                            lastGestureTime = now;
                            currentGesture = handedness === 'Left' ? 'previous' : 'next';
                        }
                    }
                }
            });
        }

        // Main initialization function
        async function init() {
            // Initialize camera first
            const cameraSuccess = await initCamera();
            
            if (cameraSuccess) {
                // Then initialize hand tracking
                await initHandTracking();
            }
            
            // Create initial dragonflies
            addDragonflies(50);
            
            // UI Event Listeners
            document.getElementById('dragonflyCount').addEventListener('input', (e) => {
                const targetCount = parseInt(e.target.value);
                const difference = targetCount - dragonflies.length;
                
                if (difference > 0) {
                    addDragonflies(difference);
                } else if (difference < 0) {
                    removeDragonflies(-difference);
                }
            });
            
            document.getElementById('wingSpeed').addEventListener('input', (e) => {
                wingSpeed = parseFloat(e.target.value);
                updateInfo();
            });
            
            document.getElementById('knotTightness').addEventListener('input', (e) => {
                knotTightness = parseFloat(e.target.value);
                updateInfo();
            });
            
            document.getElementById('knotSize').addEventListener('input', (e) => {
                knotSize = parseFloat(e.target.value);
                updateInfo();
            });
            
            document.getElementById('fractalIterations').addEventListener('input', (e) => {
                fractalIterations = parseInt(e.target.value);
                updateInfo();
            });
            
            document.getElementById('fractalScale').addEventListener('input', (e) => {
                fractalScale = parseFloat(e.target.value);
                updateInfo();
            });
            
            // New video size control
            document.getElementById('videoSize').addEventListener('input', (e) => {
                videoSize = parseFloat(e.target.value);
                updateVideoSize();
                updateInfo();
            });
            
            // Hide loading message
            document.getElementById('loading').style.display = 'none';
            
            // Animation loop
            let lastTime = 0;
            function animate(currentTime) {
                const deltaTime = (currentTime - lastTime) / 1000;
                lastTime = currentTime;
                
                requestAnimationFrame(animate);
                controls.update();
                
                // Update dragonfly movements
                updateDragonflies(deltaTime);
                
                updateInfo();
                renderer.render(scene, camera);
            }
            
            animate(0);
        }
        
        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        
        // Start the creation process
        init();
    </script>
</body>
</html>
